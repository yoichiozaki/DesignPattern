# State Pattern
- 状態の遷移をプログラムに落としていくことでプログラミングをすることができる。
	- 状態遷移図を書いてそれを元に`switch`で分岐させたり、状態とイベントのテーブルを用意して該当する状況になったら指定の関数を実行して状態を遷移するとか。
	- 上のやり方は間違っちゃいないが、オブジェクト指向では、状態をオブジェクトとして表現することによって、状態遷移図のようなプログラムを書くことができる。
	- これがState Pattern
- 状態によって挙動の異なってくる処理を「抽象メソッドとして宣言しインタフェースでまとめておいて、ここのクラスでこれを実装させる」ことで実現している。
- このパターンでは「状態遷移を誰がするか」というのが問題となる。
	- 遷移前の状態が次の状態へ遷移するところまで責任を持つのか
		- 遷移前の状態が遷移先の状態について知っておく必要ができてしまって密結合になってしまうかも
	- 遷移が固定的なら表を作ってしまうのもあり
- 状態は「ただ一つ」であって、複数の状態が同時に起きてはならないのでシングルトン
- Stateパターンを用いることで、新しい状態の追加が非常に簡単にできる。しかもコンパイル時にコンパイラが実装忘れを検出してくれる。

- Stateパターンを用いない状態遷移のプログラムの例
```
警備システムのクラス {
	金庫使用時に呼ばれるメソッド() {
		if (昼間) {
			警備センターに利用を記録
		} else if (夜間) {
			警備センターに非常事態の通報
		}
	}
	非常ベル使用時に呼ばれるメソッド() {
		警備センターに非常ベルの通報
	}
	通常通話時に呼ばれるメソッド() {
		if (昼間) {
			警備センターの呼び出し
		} else if (夜間) {
			警備センターの留守録呼び出し
		}
	}
}
```

- Stateパターンを用いる状態遷移のプログラムの例
	- `if`文がなくなる。
	- 状況ごとに考えることが可能になるので、思考の対象となる範囲が狭まってわかりやすくなる。
		- 分割統治
```
昼間という状態を表現するクラス {
	金庫使用時に呼ばれるメソッド() {
		警備センターに利用を記録
	}
	非常ベル使用時に呼ばれるメソッド() {
		警備センターに非常ベルの通報
	}
	通常通話時に呼ばれるメソッド() {
		警備センターの呼び出し
	}
}

夜間という状態を表現するクラス {
	金庫使用時に呼ばれるメソッド() {
		警備センターに非常事態の通報
	}
	非常ベル使用時に呼ばれるメソッド() {
		警備センターに非常ベルの通報
	}
	通常通話時に呼ばれるメソッド() {
		警備センターの留守録呼び出し
	}
}
```
