# Bridge Pattern
- 機能のクラスと実装のクラスを分離して、それらを橋渡しする。
- 機能のクラス階層
	- 既存のクラスに対して新たな機能を追加したい時に、その既存クラスに対して機能を追加したサブクラスを設ける。これが機能のクラス階層。
	- 機能の追加によって親子関係がどんどん深くなっていく。
		- スーパークラスは基本的な機能を持ち合わせている。
		- サブクラスで新しい機能を追加する。
- 実装のクラス階層
	- スーパークラスでAPIの仕様を抽象クラスとして規定して、その抽象クラスの子クラスとして実装を行うという形のクラス階層。
	- 実装の仕方によって子供が増えていく。
		- スーパークラスは抽象メソッドによってAPIを規定する。
		- サブクラスは具象メソッドとしてそれを実装する。

## `abstract`と`interface`について
- 共通すること
	- 指定したメソッドの実装を強制する
- 違うこと
	- `abstract`は多重継承できない
	- `interface`は幾つ実装しても良い

- 調べたところによると...
	- `interface`は外部向けで`abstract`は内部向けという印象
		- `interface`は`public`に強制される。
			- > インタフェースについてはC#言語仕様第5版では契約(contract)を定義するものと書かれており、これがすべて
			- インタフェースはドキュメントも含めて、そのインタフェースを満たすものが提供するAPIを記述すると同時に、そのインタフェースを満たすものが記述通りに動作することを契約として保証する。
			- 利用者には契約内容を具体的にどのように実現するのかは隠す。
			- 実装者には契約を守らせる。
	- `abstract`は`public`もしくは`protected`になる。
		- もちろん`public`で外部向けAPIを提供するものとして扱うこともできるが`protected`を強制することもできることを考えると、内部向けなのではないかという指摘

> JavaやC#の祖であるC++にはインターフェースがなく、その（オブジェクト指向言語としての）祖であるSimulaにもやはりインターフェースはありません（ちなみにSimulaには抽象メソッドがあるのに抽象クラスがないというやや中途半端な仕様でした）。ですから、インターフェースはより「新しい」仕組みであると言えます。そしてやや雑な言い方になりますがインターフェースだけあって継承をなくしたGo言語のような新しい言語が出てきていることも考え合わせると、抽象クラスという概念が存在するのは必要性からという以上に過去のしがらみで残っているところがあると解釈できます。

- Goの`interface`
[Ross Cox blog](https://research.swtch.com/interfaces)